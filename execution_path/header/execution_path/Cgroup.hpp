/*
 * Cgroup.hpp
 *
 * Created on: 23.11.2016
 *      Author: sload
 */

#ifndef CGROUP_HPP
#define CGROUP_HPP

#include "header/util/GlobalTypedef.hpp"

#include <boost/thread/shared_mutex.hpp> //shared_mutex
#include <memory>
#include <shared_mutex> //shared_lock
#include <unordered_map>
#include <vector>
using namespace std;
namespace execution_path
{
class Cgroup: public enable_shared_from_this<Cgroup>
{
public:

    enum Status
    {
        NEW,
        UPDATE,
        DELETE
    };

    enum Validation
    {
        NONE,
        VALID,
        INVALID,
        DELETED
    };

    /**
     * @brief generateCgroupId: generate unique Ids for the Cgroups
     * @return: new unique Id
     */
    static unsigned long generateCgroupId();

    /**
     * @brief Cgroup: Ctor
     */
    Cgroup();
    /**
     * @brief Cgroup: Ctor
     * @param events
     */
    Cgroup(vector<unsigned long> events);

    /**
     * @brief Cgroup:" Copy constructor
     * @param other: rhs
     */
    Cgroup(const Cgroup &other);


    shared_ptr<Cgroup> clone();

    /**
     * @brief set: copy all fields from other to this
     * - It is used for the recovery
     * @param other: rhs
     */
    void set(const Cgroup& other);

    /**
     * @brief getSharedPtr: return a shared pointer to this Cgroup
     * @return shared_ptr to this Cgroup
     */
    shared_ptr<Cgroup> getSharedPtr();

//    const shared_ptr<Cgroup>& getOriginal() const;
//    void setOriginal(const shared_ptr<Cgroup>& original);

    shared_ptr<Cgroup> getClonedCopy() const;
    void setClonedCopy(const shared_ptr<Cgroup> &value);

    unsigned long getId() const;

    unsigned long getExecutionPathId() const;
    void setExecutionPathId(unsigned long executionPathId);

    unsigned int getVersion() const;
    void setVersion(unsigned int version);
    void incrementVersion();

    Validation getValidation() const;
    void setValidation(Validation validation);


    const vector<unsigned long> &getEvents() const;

    /**
     * @brief pushNewEvent: add new event to the cgroup (events vector)
     * @param eventSn: Sn of the event to add
     */
    void pushNewEvent(unsigned long eventSn);

    /**
     * @brief pushNewEvent: add new event to the cgroup (events vector)
     * @param eventSn: Sn of the event to add
     * @param decreasingWeight: how much the eventsLeft will be decreased
     */
    void pushNewEvent(unsigned long eventSn, unsigned int  decreasingWeight);

    /**
     * @brief removeEventsFromBeginning: remove first  numberOfevents from events vector
     * @param numberOfevents: number of events to remove
     * @param eventsLeft: new value for events left
     */
    void removeEventsFromBeginning(unsigned int numberOfevents, unsigned int eventsLeft);

    bool contain(unsigned long eventSn) const;

    bool equal(const shared_ptr<Cgroup> &other) const;

    unsigned int getEventsLeft() const;
    void setEventsLeft(unsigned int eventsLeft);
    void decrementEventsLeft();

    ~Cgroup();

private:
    /*
    *keep a pointer to cgroup which is generated by execution path. So when we clone a cgroup
    * still we have a pointer to original one. Thus helps to update this cgroup in case of original cgroup
    *  updated
    */
//    shared_ptr<Cgroup> original=nullptr;
    shared_ptr<Cgroup> clonedCopy=nullptr;

    //unique global Id
    unsigned long Id = 0;

    //execution path Id
    unsigned long executionPathId=0;

    //as in version control, keep the number of last updated version.
    atomic<unsigned int> version={0};

    // iterator to the events that constitute the Cgroup
    vector<unsigned long> events;
    // map event Sn with event index ( event(Sn), index)
    unordered_map<unsigned long, size_t> eventsIndex;

    atomic<unsigned int> eventsLeft={0};

    Validation validation=Validation::NONE;

    unsigned int updateCounter=40;


    /*
     * used to generate unique Ids for the Cgourps.
     * Use atomic because it is accessible from multiple workers
     */
    static atomic<unsigned long> lastCgroupId;
};
}

#endif // CGROUP_HPP
